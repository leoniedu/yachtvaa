---
title: "`r format(as.Date(params$date), 'Treino: %d/%m/%Y')`"
subtitle: "Yacht Club da Bahia -- Desempenho dos Remadores vs. Vento e Corrente"
output:
  html_document:
    theme: flatly
params:
  date: "2026-01-31"
  start_time: "01:00"
  end_time: "10:00"
  athlete_ids: !expr 1:70
  cache: true
---

```{r setup, include = FALSE}
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
Sys.setlocale("LC_TIME", "pt_BR.UTF-8")
knitr::opts_chunk$set(
  echo       = FALSE,
  collapse   = TRUE,
  comment    = "#>",
  fig.width  = 8,
  fig.height = 5,
  dpi        = 150,
  warning    = FALSE,
  message    = FALSE
)

session_date  <- as.Date(params$date)
date_label    <- format(session_date, "%d/%m/%Y")
date_long     <- format(session_date, "%d de %B de %Y")
date_short    <- format(session_date, "%d %b %Y")
```

```{r packages, include = FALSE}
library(yachtvaa)
library(dplyr)
library(tidyr)
library(sf)
library(ggplot2)
library(patchwork)
library(lubridate)
```

```{r download, include = FALSE}
if (!params$cache) {
 session <- treinusr::treinus_auth()
}
use_cache <- params$cache
raw <- fetch_session_data(
  session = session,
  date        = params$date,
  start_time  = params$start_time,
  end_time    = params$end_time,
  athlete_ids = params$athlete_ids,
  cache       = use_cache,
  overwrite_db=!use_cache,
  use_memoise=FALSE
)

records <- raw$records%>%
  mutate(fullname_athlete = tolower(fullname_athlete))
buoy    <- raw$buoy

# Filtro espacial: manter todos os registros para atletas que têm pelo menos
# alguns pontos dentro da área de estudo (ao invés de manter apenas os
# pontos dentro da bbox)
records_sf <- records_to_sf(records)
study_area <- sf::st_bbox(
  c(xmin = -38.61380, ymin = -13.00741,
    xmax = -38.46308, ymax = -12.81308),
  crs = 4326L
) |>
  sf::st_as_sfc() |>
  sf::st_transform(sf::st_crs(records_sf))

# Identificar atletas que têm pelo menos um ponto dentro da área de estudo
athletes_in_bbox <- records_sf[
  lengths(sf::st_intersects(records_sf, study_area)) > 0,
  "id_athlete"
]

# Manter todos os registros para esses atletas
records_sf <- records_sf[records_sf$id_athlete %in% athletes_in_bbox$id_athlete, ]

# Criar versão filtrada para cálculos de velocidade (apenas pontos dentro da bbox)
records_sf_bbox <- records_sf[
  lengths(sf::st_intersects(records_sf, study_area)) > 0,
]

# Documentação da lógica de filtragem espacial:
# 1. Identificamos atletas que têm pelo menos um ponto dentro da bbox
# 2. Mantemos TODOS os registros desses atletas (não apenas os dentro da bbox)
# 3. Para cálculos de velocidade (como no fast500), usamos apenas pontos dentro da bbox
# 4. Aplicamos pós-filtro no fast500 para garantir início/fim dos segmentos dentro da bbox
```

### Atletas

```{r identify-paddlers}
track_summary <- records_sf |>
  st_drop_geometry() |>
  summarise(
    n_fixes      = n(),
    first_fix    = min(timestamp),
    last_fix     = max(timestamp),
    duration_min = as.numeric(difftime(max(timestamp), min(timestamp),
                                       units = "mins")),
    .by = c(id_athlete, fullname_athlete)
  )

# Distância acumulada ponto a ponto por atleta
track_distance <- records_sf |>
  arrange(id_athlete, timestamp) |>
  mutate(
    coords = st_coordinates(geometry),
    x = coords[, 1],
    y = coords[, 2],
    .keep = "unused"
  ) |>
  st_drop_geometry() |>
  summarise(
    track_distance_m = sum(sqrt(diff(x)^2 + diff(y)^2)),
    .by = id_athlete
  )

track_summary <- track_summary |>
  left_join(track_distance, by = "id_athlete")

paddlers <- track_summary |>
  filter(n_fixes >= 100, track_distance_m >= 200)

paddlers |>
  arrange(desc(track_distance_m)) |>
  mutate(
    track_distance_km = round(track_distance_m / 1000, 1),
    duration_fmt = sprintf("%d:%02d", floor(duration_min / 60), round(duration_min %% 60)),
    speed_kmh = round((track_distance_m / duration_min) * 60 / 1000, 1)
  ) |>
  select(fullname_athlete, n_fixes, duration_fmt, track_distance_km, speed_kmh) |>
  gt::gt() |>
  gt::cols_label(
    fullname_athlete = "Atleta",
    n_fixes = "Pontos GPS",
    duration_fmt = "Duração (h:mm)",
    track_distance_km = "Distância (km)",
    speed_kmh = "Vel. (km/h)"
  ) |>
  gt::tab_caption("Atletas identificados na água") |>
  gt::tab_options(
    table.font.size = gt::px(12),
    data_row.padding = gt::px(2),
    column_labels.padding = gt::px(4)
  ) |>
  gt::opt_interactive(page_size_default = 100)
```

```{r filter-paddlers, include = FALSE}
records_sf <- records_sf |>
  filter(id_athlete %in% paddlers$id_athlete)

n_paddlers <- nrow(paddlers)
```

```{r fastest-500, include = FALSE}
fast500 <- fastest_straight_distance(
  records_sf_bbox,
  athlete_col = "id_athlete",
  time_col    = "timestamp",
  distance_m  = 500
)

# Post-filtro: garantir que os pontos de início e fim dos segmentos estejam
# dentro da área de estudo (bbox)
if (nrow(fast500) > 0) {
  # Criar pontos de início e fim dos segmentos
  start_points <- sf::st_as_sf(
    fast500,
    coords = c("start_x", "start_y"),
    crs = sf::st_crs(records_sf)
  )
  end_points <- sf::st_as_sf(
    fast500,
    coords = c("end_x", "end_y"),
    crs = sf::st_crs(records_sf)
  )

  # Verificar quais estão dentro da bbox
  start_in_bbox <- lengths(sf::st_intersects(start_points, study_area)) > 0
  end_in_bbox <- lengths(sf::st_intersects(end_points, study_area)) > 0

  # Filtrar resultados para manter apenas segmentos com ambos os pontos na bbox
  fast500 <- fast500[start_in_bbox & end_in_bbox, ]
}

# Anexar nomes dos atletas
fast500 <- fast500 |>
  left_join(
    paddlers |> select(id_athlete, fullname_athlete),
    by = "id_athlete"
  )
```

### Mapa

```{r fastest-map, fig.height = 8.6, fig.width = 13.8, fig.cap = "Trechos mais rápidos de 500 m em linha reta. Setas indicam a direção do percurso."}
arrow_df <- fast500 |>
  as_tibble()

basemap <- maptiles::get_tiles(records_sf, provider = "CartoDB.Positron",
                               crop = FALSE, verbose = FALSE)

ggplot() +
  tidyterra::geom_spatraster_rgb(data = basemap) +
  geom_sf(data = records_sf, colour = "grey50", size = 0.1, alpha = 0.4) +
  geom_segment(
    data = arrow_df,
    aes(x = start_x, y = start_y, xend = end_x, yend = end_y,
        colour = avg_speed_kmh),
    arrow = arrow(length = unit(0.3, "cm"), type = "closed"),
    linewidth = 1.3
  ) +
  ggrepel::geom_text_repel(
    data = arrow_df,
    aes(x = (start_x + end_x) / 2, y = (start_y + end_y) / 2,
        label = fullname_athlete),
    size = 2.5, max.overlaps = 20,
    bg.color = "white", bg.r = 0.15
  ) +
  scale_colour_viridis_c(option = "plasma", name = "Vel. (km/h)") +
  coord_sf(crs = sf::st_crs(records_sf)) +
  labs(
    title    = paste("Trechos mais rápidos de 500 m --", date_short),
    subtitle = "Setas indicam a direção do percurso; cor = velocidade do atleta"
  ) +
  theme_void(base_size = 11) +
  theme(
    legend.position = "bottom",
    plot.title      = element_text(face = "bold"),
    plot.margin     = margin(5, 5, 5, 5)
  )
```

### Boia

```{r buoy-setup, include = FALSE}
buoy_ip <- interpolate_buoy(buoy)

has_wind <- "wind_speed" %in% names(buoy_ip) &&
  any(!is.na(buoy_ip$wind_speed))

# Limit buoy data to the training period
records_time_range <- range(records_sf$timestamp)
buoy_ip_training <- buoy_ip |>
  filter(datetime >= records_time_range[1], datetime <= records_time_range[2])

buoy_current <- buoy_ip_training |>
  filter(!is.na(current_speed_kmh)) |>
  mutate(local_time = with_tz(datetime, tzone = "America/Bahia"))

if (has_wind) {
  buoy_wind <- buoy_ip_training |>
    filter(!is.na(wind_speed)) |>
    mutate(
      wind_speed_kmh = wind_speed * 3.6,
      local_time     = with_tz(datetime, tzone = "America/Bahia")
    )
}
```

```{r buoy-table, echo = FALSE}
buoy_local <- buoy_ip |>
  mutate(
    local_time = with_tz(datetime, "America/Bahia"),
    hour = format(floor_date(local_time, "hour"), "%Hh")
  ) |>
  filter(
    datetime >= floor_date(records_time_range[1], "hour") - hours(1),
    datetime <= ceiling_date(records_time_range[2], "hour") + hours(1)
  )

current_h <- buoy_local |>
  filter(!is.na(current_speed_kmh)) |>
  summarise(
    speed = round(mean(current_speed_kmh, na.rm = TRUE), 1),
    dir   = round(mean(current_direction, na.rm = TRUE), 0),
    .by = hour
  ) |>
  arrange(hour)

dir_arrow <- function(deg, from = FALSE) {
  if (from) deg <- (deg + 180) %% 360
  arrows <- c("\u2191", "\u2197", "\u2192", "\u2198",
              "\u2193", "\u2199", "\u2190", "\u2196")
  ifelse(is.na(deg), "\u2014", arrows[(round(deg / 45) %% 8) + 1])
}

metrics_long <- bind_rows(
  tibble(hour = current_h$hour, metric = "Corrente (km/h)",
         value = as.character(current_h$speed)),
  tibble(hour = current_h$hour, metric = "Dir. corrente",
         value = dir_arrow(current_h$dir))
)

if (has_wind) {
  wind_h <- buoy_local |>
    filter(!is.na(wind_speed)) |>
    summarise(
      speed = round(mean(wind_speed * 3.6, na.rm = TRUE), 0),
      dir   = round(mean(wind_direction, na.rm = TRUE), 0),
      .by = hour
    ) |>
    arrange(hour)

  metrics_long <- bind_rows(
    tibble(hour = wind_h$hour, metric = "Vento (km/h)",
           value = as.character(wind_h$speed)),
    tibble(hour = wind_h$hour, metric = "Dir. vento",
           value = dir_arrow(wind_h$dir, from = TRUE)),
    metrics_long
  )
}

metric_order <- c("Vento (km/h)", "Dir. vento", "Corrente (km/h)", "Dir. corrente")
all_hours <- sort(unique(metrics_long$hour))

metrics_wide <- metrics_long |>
  mutate(
    metric = factor(metric, levels = metric_order),
    hour = factor(hour, levels = all_hours)
  ) |>
  arrange(metric, hour) |>
  pivot_wider(names_from = hour, values_from = value, values_fill = "\u2014")

metrics_wide |>
  gt::gt() |>
  gt::cols_label(metric = "") |>
  gt::tab_caption(paste("Boia SIMCOSTA 515 \u2014", date_short)) |>
  gt::tab_options(
    table.font.size = gt::px(12),
    data_row.padding = gt::px(2),
    column_labels.padding = gt::px(4)
  )
```

```{r match-buoy, include = FALSE}
buoy_for_match <- buoy_ip |>
  transmute(
    datetime,
    wind_direction_deg    = if ("wind_direction" %in% names(buoy_ip))
      wind_direction else NA_real_,
    wind_speed_kmh        = if ("wind_speed" %in% names(buoy_ip))
      wind_speed * 3.6 else NA_real_,
    current_direction_deg = current_direction,
    current_speed_kmh     = current_speed_kmh,
    wave_height,
    wave_direction
  )

matched <- match_buoy_to_segments(fast500, buoy_for_match)
```

```{r apparent, include = FALSE}
conditions <- apparent_conditions(matched, impute_missing_wind = !has_wind)
```

### Corrente & Vento

```{r polar-plots, fig.height = 5, fig.width = 14, fig.cap = "Corrente e vento relativos ao rumo do trecho mais rápido."}
current_polar <- conditions |>
  as_tibble() |>
  filter(!is.na(current_speed_kmh)) |>
  mutate(current_relative_deg = (current_direction_deg - bearing_deg) %% 360)

current_r_max <- max(5, max(current_polar$current_speed_kmh, na.rm = TRUE))

p_current <- ggplot(current_polar, aes(x = current_relative_deg, y = current_speed_kmh)) +
  geom_point(aes(colour = avg_speed_kmh), size = 3) +
  ggrepel::geom_text_repel(aes(label = fullname_athlete), size = 2.5, max.overlaps = 20) +
  coord_polar(start = 0, direction = -1) +
  scale_x_continuous(
    limits = c(0, 360), breaks = c(0, 90, 180, 270),
    labels = c("A favor", "90\u00b0", "Contra", "270\u00b0")
  ) +
  scale_y_continuous(limits = c(0, current_r_max)) +
  scale_colour_viridis_c(option = "plasma", name = "Vel. (km/h)") +
  labs(title = "Corrente", x = NULL, y = "Vel. corrente (km/h)") +
  theme_minimal(base_size = 10)

if (has_wind) {
  wind_polar <- conditions |>
    as_tibble() |>
    filter(!is.na(wind_speed_kmh)) |>
    mutate(wind_relative_deg = (wind_direction_deg + 180 - bearing_deg) %% 360)

  wind_r_max <- max(30, max(wind_polar$wind_speed_kmh, na.rm = TRUE))

  p_wind <- ggplot(wind_polar, aes(x = wind_relative_deg, y = wind_speed_kmh)) +
    geom_point(aes(colour = avg_speed_kmh), size = 3) +
    ggrepel::geom_text_repel(aes(label = fullname_athlete), size = 2.5, max.overlaps = 20) +
    coord_polar(start = 0, direction = -1) +
    scale_x_continuous(
      limits = c(0, 360), breaks = c(0, 90, 180, 270),
      labels = c("A favor", "90\u00b0", "Contra", "270\u00b0")
    ) +
    scale_y_continuous(limits = c(0, wind_r_max)) +
    scale_colour_viridis_c(option = "plasma", name = "Vel. (km/h)") +
    labs(title = "Vento", x = NULL, y = "Vel. vento (km/h)") +
    theme_minimal(base_size = 10)

  p_current + p_wind +
    plot_layout(guides = "collect") &
    theme(legend.position = "bottom")
} else {
  p_current
}
```

### Classificação

```{r league}
league <- build_league_table(conditions, athlete_col = "fullname_athlete")
league_fmt <- format_league(league, top_n = 15)

wind_class_pt <- c(
  calm = "calmo", headwind = "contra", tailwind = "a favor",
  crosswind_right = "lateral dir.", crosswind_left = "lateral esq."
)
current_class_pt <- c(
  following = "a favor", opposing = "contra",
  cross_right = "lateral dir.", cross_left = "lateral esq."
)

league_fmt |>
  mutate(
    tempo = sprintf("%d:%02d", floor(predicted_time_sec / 60),
                    round(predicted_time_sec %% 60)),
    avg_speed_kmh = round(avg_speed_kmh, 1),
    vento = paste0(wind_class_pt[wind_class], " (",
                   round(wind_component_kmh, 1), " km/h)"),
    corrente = paste0(current_class_pt[current_class], " (",
                      round(current_component_kmh, 1), " km/h)")
  ) |>
  select(rank, fullname_athlete, tempo, avg_speed_kmh, vento, corrente) |>
  gt::gt() |>
  gt::cols_label(
    rank = "#",
    fullname_athlete = "Atleta",
    tempo = "Tempo",
    avg_speed_kmh = "Velocidade (km/h)",
    vento = "Vento",
    corrente = "Corrente"
  ) |>
  gt::tab_caption(paste("Classificação: 500 m mais rápidos em", date_short)) |>
  gt::tab_options(
    table.font.size = gt::px(12),
    data_row.padding = gt::px(2),
    column_labels.padding = gt::px(4)
  ) |>
  gt::opt_interactive(page_size_default = 100) |>
  gt::cols_width(fullname_athlete~gt::px(200), rank~gt::px(30), 
  tempo~gt::px(60), avg_speed_kmh~gt::px(90))
```

### Resumo

```{r summary-stats, results = "asis"}
current_summary <- buoy_current |>
  summarise(
    mean_speed = round(mean(current_speed_kmh, na.rm = TRUE), 2),
    max_speed  = round(max(current_speed_kmh, na.rm = TRUE), 2),
    mean_dir   = round(mean(current_direction, na.rm = TRUE), 0)
  )

avg_dur_min <- mean(paddlers$duration_min, na.rm = TRUE)
avg_dur_fmt <- sprintf("%d:%02d", floor(avg_dur_min / 60), round(avg_dur_min %% 60))

winner      <- league_fmt$fullname_athlete[1]
winner_sec  <- league_fmt$predicted_time_sec[1]
winner_time <- sprintf("%d:%02d", floor(winner_sec / 60), round(winner_sec %% 60))
winner_kmh  <- round(league_fmt$avg_speed_kmh[1], 1)

if (has_wind) {
  wind_summary <- buoy_wind |>
    summarise(
      mean_speed = round(mean(wind_speed_kmh, na.rm = TRUE), 1),
      max_speed  = round(max(wind_speed_kmh, na.rm = TRUE), 1),
      mean_dir   = round(mean(wind_direction, na.rm = TRUE), 0)
    )
  wind_line <- sprintf(
    "- **Vento:** média %s km/h (máx %s), predominante de %s°",
    wind_summary$mean_speed, wind_summary$max_speed, wind_summary$mean_dir
  )
} else {
  wind_line <- "- **Vento:** sem dados disponíveis (imputado como zero)"
}

cat(sprintf(
  "**Resumo do treino:**\n\n
- **Data:** %s
- **Atletas na água:** %d
- **Duração média:** %s (h:mm)
%s
- **Corrente:** média %s km/h (máx %s), fluindo para %s°
- **500 m mais rápido:** %s em %s (%s km/h)\n",
  date_label,
  n_paddlers,
  avg_dur_fmt,
  wind_line,
  current_summary$mean_speed, current_summary$max_speed, current_summary$mean_dir,
  winner, winner_time, winner_kmh
))
```
